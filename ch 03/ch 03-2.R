# 벡터( 1차원 데이터 , 원소의 묶음 / 문자는 "" 사용)
s <- c(1,2,3,4,5,6)
s2 <- c(1:6)         # 시작:끝
s3 <- c(6:1)
s4 <- 1:5
c(1:3, c(1:6)) # 벡터로 묶었을때 (1 ~ 6, 1,2,3) 이 아닌 각 벡터의 순서대로 1 ~ 3 , 1 ~ 6으로 묶임을 알 수 있다.
c(1:30)
seq(1, 100, by=2) # from, to , increment by = 숫자간의 간격 설정
seq(from=100, to=1, by=-3)
seq(0, 1, by=0.1)
seq(0, 1, length.out=11) # 0 ~ 1 까지 범위에서 (length.out)11개 엘리먼트 길이의 수열을 만들어줘

rep(c(1:3), times=2) # 1 2 3 1 2 3 / 1 ~ 3까지의 범위로 2번 반복해줘
rep(c(1:3), each=2)  # 1 1 2 2 3 3 / 1 ~ 3까지의 범위인데 각각의 원소를 두번 반복해줘
rep(c(1:3), times=c(1,2,3)) # 1은 1번 2는 2번 3은 3번 반복이 된다.

# 숫자형 벡터와 문자형 벡터를 묶으면
num <- 

# 인덱싱
x <- seq(2,10,by=2) # 2 ~ 10 까지의 범위에서 2 간격인 수열 
x[1] # []는 묶음 혹은 수열에서 [n]번째의 원소를 나타냄.
x[-1] # 첫 번째 원소를 제외한다.
x[-3] # 세 번째 원소를 제외한다.

#slicing
x[1:3] # 2, 3, 6
x[c(1,3,5)] # 벡터를 제외한 [1,3,5] 커맨드가 안먹힘, 필요한 엘리먼트만 뽑기 위해 벡터를 사용  
x[-c(2,4)] 

# 연산
x <- c(1:4)
y <- c(5:8)
z <- c(3,4)
w <- c(5:7)

x + 2 # 3 4 5 6  
x + y # 6 8 10 12
x + z # 4 6 6 8 
x + w # 6 8 10 9

length(w) # 해당 변수의 묶음 또는 수열의 개수 표현

x > 2
all(x>2) # AND
any(x>2) # OR

# fancy indexing
y[x>2]

x <- 1:10
head(x)
head(x, 3)
tail(x,3)

# 집합 연산
x <- 1:3
y <- 3:5
z <- c(3,1,2)

union(x, y)    #합집합(중복 없이)
intersect(x,y) #교집합
setdiff(x, y)  #차집합
setdiff(y, x)
setequal(x, y) # F
setequal(x, z) # T


